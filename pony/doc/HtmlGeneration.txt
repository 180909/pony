Генерация HTML
==============

Пони предоставляет два способа генерации HTML страниц:

  * Декоратор @printhtml в совокупности с оператором print
  * Язык шаблонов

Первый способ, который мы рассмотрим в этой главе, предназначен в основном
для простых приложений. Второй способ более гибкий и мощный, его мы рассмотрим
чуть позже. __ссылка Templating__



### Использование декоратора @printhtml и оператора print


Пример использования оператора print для генерации страницы:

    >>> from pony.main import *             (1)
    >>> @http                               (2)
    ... @printhtml                          (3)
    ... def test():                         (4)
    ...     print "<html>"                  (5)
    ...     print "<head><title>Hello world!</title></head>"
    ...     print "<body><h1>Hello world!</h1></body>"
    ...     print "</html>"
    ... 
    >>> http.start()                        (6)
    Starting HTTP server at localhost:8080

  (1) Импортируем все необходимые компоненты Пони  
  (2) Декоратор `@http` указывает, что эта функция будет обработчиком URL (см. URL роутинг)  
  (3) Если функция отдекорирована с помощью `@printhtml`, оператор `print` служит для генерации содержимого страницы.
      Порядок декораторов важен. `@http` должен идти в тексте програмы выше чем `@printhtml`, а не наоборот.
      Если используются еще какие-либо декораторы, то `@http` должен быть самым верхним, а `@printhtml` - самым нижним.  
  (4) Объявляем функцию `test()`  
  (5) Генерируем содержимое страницы с помощью оператора `print`  
  (6) Запускаем веб-сервер

Если теперь набрать адрес http://localhost:8080/test в браузере, то мы увидим страницу:

__картинка. текст Hello world в браузере__

Если мы посмотрим на HTML код страницы в браузере, то увидим, что он полностью соответствует
тому коду, который мы указали в теле функции test:

__ картинка. код в окне браузера__


Возможность задать HTML код каждой страницы от начала и до конца безусловно дает разработчику максимум возможностей. 
Однако на практике каждая страница веб-сайта имеет часть, которая общая для всех. Обычно это CSS стили, которые
едины для всего содержимого веб-сайта.
Чтобы избавить разработчика от рутинной работы, Пони позволяет включать общие для всех страниц части автоматически.

    @webpage
    def test():
        print "<title>Hello world!</title>"
        print "<h1>Hello world!</h1>"

Сгенерированная страница выглядит теперь так:

__картинка. Hello world, отформатирован по другому__

А HTML код страницы так:

__картинка. код в окне браузера, с CSS стилями__    

Пони автоматически задала повторяющиеся для каждой страницы тэги (html, head, body и пр.), а также присоединила
стандартные стили CSS. Тэг title добавлен в содержимое тэга head, тогда как остальная часть документа в
тэг body. Пони автоматически включает заданные разработчиком тэги в соответствующее место документа согласно
стандарту HTML.
В последнем примере используется декоратор @webpage. Этот декоратор удобный аналог пары декораторов
@http и @printhtml, следующих один за другим.

Пони избавляет разработчика от рутинной работы и в то же время дает полную свободу когда это требуется.
Разработчик задает наполнение страницы, а Пони встраивает этот текст в общий для всех страниц шаблон,
в нужное место (внутрь тегов <head> или <body>). О том как работать со стандартным шаблоном можно почитать в разделе
"Стандартные стили CSS" __ссылка на Стандартные стили CSS__.
Если разработчик сам задает тэги <html>, <head> или <body>, Пони не будет менять их содержимое.
Если генерируемый документ начинается с тэга DOCTYPE, Пони считает, что разработчик хочет сам
задать HTML код страницы целиком. С генерируемым HTML кодом в этом случае не происходит никаких трансформаций.




#### Безопасные и небезопасные строки ###


Веб приложения могут быть подвержены Cross-Site Scripting (XSS) атаке.
Суть этой атаки в следующем. Допустим есть веб-сайт, на котором есть форум. 
Злоумышленник под видом сообщения передает на сайт javascript код. Веб-приложение сохраняет
этот код в базе данных как и любое другое сообщение.
Теперь у любого пользователя, который откроет страницу, содержащую это сообщение, выполнится переданный злоумышленником javascript код. 
Чтобы защититься от такого рода атак, все данные, которые получены сервером от пользователя должны пройти процесс эскапирования -
преобразования символов &amp;,&lt;,&quot;,&gt;,&#39; в их эквиваленты для безопасного представления на странице.

В большинстве современных веб-фреймворков для того, чтобы выполнилось такое преобразование, нужно вызвать специальную функцию.
Такой подход неудобен и чреват ошибками. В Пони реализована более удобная концепция.
Строки, которые генерируются в Пони, являются экземплярами класса Html. Это безопасные строки.
Любой текст, который Пони получает извне(от пользователя или из базы данных), считается небезопасной строкой. Любое соединение небезопасной строки
со строкой Html приводит к эскапированию небезопасной строки перед соедниением. Таким образом, если пользователь передал в веб-приложение
код, при генерации страницы этот код будет преобразован в безопасную строку и выведен как обычный текст.

Рассмотрим сказаное выше на примере:

    @webpage
    def test(author, message):
        print "<html><h1>"
        print author
        print "</h1>"
        print "<p><h4>"
        print message
        print "</h4></p></html>"

В функцию, которая генерирует страницу, пользователь передает имя и сообщение.
Теперь откроем страницу в браузере:

    http://localhost:8080/test?author=John&message=<script>alert("javascript_code")</script>

В окне браузера мы увидим:

    __картинка. код отображен как текст__    

В этом примере мы передали javascript код под видом сообщения. Но при генерации страницы этот код был выведен
как текст. Это произошло потому, что Пони произвела преобразование небезопасной строки, полученной от пользователя.
Все строки, которые написаны разработчиком считаются безопасными. Все остальные, которые получены извне (от пользователя
или из базы данных) считаются опасными и проходят обязательное преобразование. Это преобразование заменяет символы
&amp;,&lt;,&quot;,&gt;,&#39; на их эквиваленты для безопасного представления на странице.  
Если разработчик по какой то причине не хочет, чтобы переданный в функцию текст преобразовывался в безопасную строку,
он может это сделать с помощью класса Html. Если мы заменим строчку

    print message

на такой код

    print Html(message)

то тем самым мы сообщаем Пони, что строка message безопасная и с ней не нужно производить никаких преобразований.
Теперь, если мы откроем ту же самую страницу в браузере, то увидим, что браузер выполнит javascript код, который
мы передали под видом сообщения:

    __картинка с окошком Alert__    




### Особенности декоратора @printhtml ###

Использование декоратора @printhtml накладывает на разработчика некоторые ограничения.

  1. Декоратор @printhtml не работает в Google Application Engine.
  2. В функции, которая отдекорирована @printhtml все строковые константы заменяются на безопасные строки.

Первое ограничение вызвано тем, что при использовании этого декоратора Пони выполняет компиляцию кода.
Это делается для того, чтобы обеспечить безопасность строк внутри функции. GAE не позволяет выполнять компиляцию.

Второе ограничение вызвано особенностями реализации Пони.
При использовании декоратора @printhtml, все строковые константы в функции заменяются на безопасные строки.
Рассмотрим пример, где декорируемая функция содержит строки, которые используются для обращения к базе данных:

    @http
    @printhtml
    def page():
        db = connect("mydatabase")
        messages = db.execute("select * from messages").fetchall()
        for msg in messages:
            print msg
            print "<br>"

В этом примере строки "mydatabase" и "select * from messages" не следует заменять на безопасные.
Избежать замены можно двумя способами. Первый способ - вынести всю логику работы с базой данных в
отдельную функцию:

    def get_messages():
        db = connect("mydatabase")
        messages = db.execute("select * from messages").fetchall()
        return messages

    @http
    @printhtml
    def page():
        messages = get_messages()
        for msg in messages:
            print msg
            print "<br>"
    
Второй способ - добавить [:] после каждой строки, которая не нуждается в замене:

    @http
    @printhtml
    def page():
        db = connect("mydatabase"[:])
        messages = db.execute("select * from messages"[:]).fetchall()
        for msg in messages:
            print msg
            print "<br>"

Такой трюк работает из-за особенностей реализации Питона.   
Использование шаблонов, речь о которых пойдет далее позволяет избежать этих ограничений.




### Потокобезопасность оператора print внутри Пони ###


Использование декоратора @printhtml в совокупности с оператором print имеет свои ограничения, но
в то же время этот способ очень удобен для ряда приложений.
В современных фреймворках такой способ вывода можно встретить нечасто.
Дело в то, что для использования print для такой цели необходимо выполнять редирект вывода.
Эта операция не является потокобезопасной в Питоне.
В Пони реализация редиректа вывода является потокобезопасной.
По мере выполнения кода функции, в которой используется print, Пони накапливает генерируемую страницу в буффере,
а затем выводит результат, когда заканчивается код функции.
