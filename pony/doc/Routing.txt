URL Роутинг
===========


Назначение веб приложения — генерировать страницы, которые пользователь открывает в браузере.
В некоторых языках программирования, например в PHP, для генерации страницы запускается
отдельный файл (имя файла берется из адреса страницы). Программа на Питоне состоит из набора функций,
и для её хранения часто достаточно одного файла. Пони предполагает, что генерация страницы
будет осуществлена в результате выполнения одной из функций программы.

Роутингом называется процесс определения, какую именно пользовательскую функцию
должна запустить Пони, чтобы сгенерировать страницу, расположенную по определенному
адресу. Иногда возникает и обратная задача — глядя на функцию понять, какому адресу
на сайте она соответствует.

Схематично, процесс обработки запроса в Пони выглядит следующим образом:
    
  1.  Пользователь набирает адрес страницы в браузере.
  2.  HTTP-запрос передается браузером веб-серверу.
  3.  Веб-сервер передает запрос Пони.
  4.  Пони анализирует запрос, находит соответствующий обработчик, при необходимости
      выделяет из URL параметры и производит вызов функции-обработчика с этими параметрами.
  5.  Функция-обработчик генерирует страницу, которая передается веб-серверу, а затем браузеру пользователя.




Сопоставление URL вызову конкретной функции-обработчика
---------------------------------------------------------


Основное назначение роутинга - связать набранный пользователем URL с функцией на сервере.
Многие фреймворки используют для этой цели регулярные выражения. Регулярные выражения,
безусловно, очень мощный инструмент, но не все пользователи считают его простым и удобным.
Пони предлагает мощный, гибкий, и в то же время достаточно простой способ для решения этой
задачи — использование специального декоратора `@http`, в котором при необходимости может
указываться шаблон URL, заданный с помощью специального синтаксиса.




### Простейший пример использования декоратора `@http` ###


Давайте посмотрим как сопоставить URL с функцией-обработчиком. Вот пример законченной программы,
которая генерирует страницу с помощью Пони.

    from pony.main import *     (1)

    @http                       (2)
    def hello():                (3)
        return "Hello world!"   (4) 

    http.start()                (5) 

(1) В первой строчке мы с помощью "звездочки" импортируем все самое необходимое для Пони.
После того как выполнен import, мы можем использовать компоненты Пони в нашем коде.  
(2) Здесь функция `hello` предваряется декоратором `@http`.
Тем самым мы сообщаем Пони, что эта функция будет обработчиком для URL и доступна для пользователей веб-сайта.  
(3) Далее мы объявляем функцию `hello`.  
(4) Возвращаемым из функции значением будет строка "Hello world!".  
(5) Запускаем веб-сервер. По умолчанию веб-сервер обслуживает порт 8080.  
Как и все примеры, мы можем запустить этот пример из интерактивного режима и
посмотреть что получилось.  

После того как мы запустили приведенный выше код в интерактивном режиме или в виде отдельного файла,
мы можем посмотреть на сгенерированую страницу в браузере. Давайте разберемся, какой URL нужно
набрать, чтобы увидеть результат.
Когда мы указываем декоратор `@http` без параметров, Пони по умолчанию строит URL используя имя самой функции.
В этом примере соответствующий данной функции URL будет "/hello".
Наберем в браузере http://localhost:8080/hello и увидим наше приветствие:

![routing1](/pony/static/img/doc/routing1.png)  
  
Как вы видите из примера, связать URL с функцией-обработчиком в Пони очень просто.  


В случае, если Пони не находит для URL ни одной подходящей функции, генерируется страница
с кодом ошибки "404 Not Found".
В режиме отладки на эту страницу выводится список всех зарегистрированных шаблонов URL.

![routing2](/pony/static/img/doc/routing2.png)  




### Передача параметров в функцию ###


На практике часто возникает необходимость передать параметры на сервер.
Самый простой способ сделать это в Пони — добавить необходимый параметр в функцию-обработчик:

    @http
    def hello(name):
        return "Hello " + name + "!"

Здесь мы добавили в функцию параметр `name`, который будет отображаться на генерируемой странице.

URL для этой страницы будет немного отличаться от предыдущего.
У функции hello теперь есть обязательный параметр. Раз этот параметр обязательный,
он должен присутствовать в URL. Поскольку мы не задали, как должна выглядеть URL,
Пони ожидает, что параметр будет указан после знака вопроса:

    http://localhost:8080/hello?name=Pony

Если мы наберем этот адрес в браузере, то увидим страницу, сгенерированную Пони:

![routing3](/pony/static/img/doc/routing3.png)




### Значения по умолчанию ###


Если мы хотим, чтобы у параметра было значение по умолчанию, нужно указать это в объявлении
функции:

    @http
    def hello(name="WORLD"):
        return "Hello %s!" % name

Теперь, если мы не будем указывать ни одного параметра в URL, мы увидим, что Пони будет использовать
значение по умолчанию:

![routing4](/pony/static/img/doc/routing4.png)

Кроме того, мы также можем указать значение параметра в URL явно:

![routing5](/pony/static/img/doc/routing5.png)

Если присмотреться к коду последнего примера, можно заметить, что здесь мы получаем
результирующую строку не сложением строк, как в предыдущем примере, а другим,
более удобным способом — подстановкой:

    return "Hello %s!" % name

В этом примере `%s` определяет место, куда будет подставлен параметр `name`.




### Произвольные URL для функции-обработчика ###


До текущего момента при использовании декоратора @http мы не указывали явно, как
должна выглядеть URL, поэтому Пони использовала алгоритм по умолчанию.
При этом Пони считает, что сначала в URL идет имя функции, а затем, после
знака вопроса - параметры. Это стандартный способ для передачи параметров
HTML-формы методом GET. Если мы хотим, чтобы URL был более компактным и легко
читаемым, можно указать шаблон URL в декораторе `@http`:
    
    @http("/hello/$name")
    def hello(name):
        return "Hello %s!" % name

Та часть шаблона, которая идет после знака $, называется параметром. Вместо нее
в URL могут быть переданы любые допустимые символы (кроме слэша /). Имена параметров
в URL должны точно соответствовать именам параметров самой функции.
Если требуется, чтобы символ $ присутствовал в самом URL, нужно его записать как $$,
чтобы дать понять Пони, что далее идет не переменная, а знак $.

В шаблоне мы указали, что после символов `hello/` в URL ожидается переменная часть, которая будет
передана в функцию в качестве параметра `name`. Теперь при попытке перейти по URL
http://localhost:8080/hello/Pony будет запущена наша функция, и в качестве значения
параметра в нее будет передана строка "Pony"

![routing6](/pony/static/img/doc/routing6.png)

Параметр может располагаться в любом месте URL. Например в середине:

    @http('/hello/$name/page.html')
    def hello(name):
        return "Hello %s!" % name

Разделителем между параметрами может быть не только символ "/". Допускается практически любой символ,
допустимый в URL, кроме букв, цифр и знака подчеркивания. Например:

    @http('/archive/$year-$month/posts')
    def archive2(year=None, month=None):
        return "archive2"
    
Параметров может быть несколько:

    @http("/page/$a/$b/$c")
    def test(a, b, c):
        return "Hello, %s %s %s!" % (a, b, c)

Если мы хотим, чтобы параметры передавались обычным способом (после знака `?` в URL), мы можем это указать в шаблоне
таким способом:

    @http("/page?a=$a&b=$b")
    def test(a, b):
        return "Hello, %s %s!" % (a, b)

Переменными частями здесь будут `$a` и `$b`. В такой записи параметры указываются рядом с именами самих переменных,
поэтому их порядок в URL не важен. Например оба этих URL будут адресованы той же самой функции:

* /http://localhost:8080/page?a=1&b=2
* /http://localhost:8080/page?b=2&a=1

Случается ситуация, когда URL, который написан в декораторе отличается от того, который набран в
браузере только наличием или отсутствием знака "/" на конце. Для пользователя веб-сайта эта разница
может быть не очевидна, поэтому Пони в такой ситуации попробует помочь пользователю все же увидеть запрашиваемую страницу.
Когда Пони анализирует URL полученный от браузера она сначала попытается найти точное соответствие.
Если точное соответствие есть - вызывается соответствующий обработчик.
Если точное совпадение не найдено, Пони попробует убрать/подставить слэш в конце URL (или перед знаком `?`) и найти
обработчик для такого URL. Если при этом найдено соответствие, Пони автоматически выполняет редирект
по найденному адресу. Таким образом для приведенных ранее примеров URL `/hello/Pony/`
будет автоматически переадресован на `/hello/Pony`, а `/page/?a=1&b=2` будет автоматически переадресован
на `/page?a=1&b=2`.




### Несколько URL для одного обработчика ###


В какой то момент вам может понадобиться изменить структуру адресов веб-сайта.
Используя возможности Пони это можно сделать довольно быстро, но нам нужно помнить, что некоторые пользователи
могли сделать закладки, используя старые адреса. Если просто поменять URL страниц,
то закладки, сделанные с использованием старых адресов, перестанут работать. 
Пользователи, которые приходят
на ваш веб-сайт через поисковую машину тоже будут испытывать неудобства — пройдет какое-то время,
пока она перестроит индекс и заменит старые URL на новые.

Используя роутинг в Пони можно очень легко изменять структуру веб-сайта,
не нарушая при этом работы тех пользователей, которые привыкли работать со старой структурой.
Одной и той же функции-обработчику может быть сопоставлено несколько URL:

    @http("/hello?name=$name")
    @http("/hi/$name")
    def hello(name="WORLD"):
        return "Hello %s!" % name

При обработке первого указанного URL мы можем использовать либо имя заданное по умолчанию, либо стандартную
передачу параметра в функцию:

![routing7](/pony/static/img/doc/routing7.png)

![routing8](/pony/static/img/doc/routing8.png)

Второй URL связанный с этой функцией отображает ту же самую страницу.

Хорошим тоном считается иметь один постоянный адрес для страницы. Обращения к той же самой странице
по другим URL следует переадресовывать на постоянный адрес. Мы поговорим об этом подробнее далее 
в этой главе, а сейчас просто сделаем переадресацию с одного URL на другой. Для этого добавим
в декоратор первого URL параметр `redirect=True`:

    @http("/hello?name=$name", redirect=True)
    @http("/hi/$name")
    def hello(name):
        return "Hello %s!" % name

Теперь, обращаясь к странице по URL `/hello?name=Pony`, мы автоматически попадем на страницу `/hi/Pony`    

До текущего момента наши страницы генерировалась в виде простого текста.
Тип генерируемой страницы в Пони по умолчанию — `plain/text`.
Чтобы сгенерировать HTML страницу нам нужно просто указать параметр type='text/html' в декораторе:

    @http(type="text/html")
    def hello(name="world"):
        return "<html><h1>Hello %s!<h1></html>" % name

Теперь страница выглядит совсем по-другому:

![routing9](/pony/static/img/doc/routing9.png)

В Пони существуют и более удобные способы генерации HTML страниц - с помощью
специального декоратора `@printhtml` и функции `html`.
Если вдобавок к декоратору @http добавить декоратор @printhtml, 
то можно использовать команду print для генерации фрагмента HTML страницы: 
    
    @http(type="text/html")
    @printhtml
    def hello(name="world"):
        print "<html><h1>"
        print "Hello %s!" % name
        print "</h1></html>"

Без декоратора @printhtml результат команды print попадает на консоль, а если используется этот декоратор,
то строки накапливаются в threadlocal-буфере и затем выводятся как результат функции. Еще более мощным средством
для генерации HTML шаблонов является функция html. Подробнее о использовании этой функции можно почитать __здесь__

Если используются сразу оба декоратора @http и @printhtml (одни, или совместно с другими декораторами),
то @http должен быть самым верхним, а @printhtml - самым нижним.
Для удобства можно использовать декоратор @webpage.
Эффект от его применения эквивалентен использованию двух декораторов -
@http и @printhtml. В @webpage можно передавать те же параметры, что и в @http:

    @webpage(type="text/html")
    def hello(name="world"):
        print "<html><h1>"
        print "Hello %s!" % name
        print "</h1></html>"        




### Генерация URL для функции-обработчика ###


Ранее мы познакомились с тем, как отображать URL на функцию-обработчик.
Часто при построении динамического веб-сайта возникает обратная задача — отобразить
URL, который соответствует определенной функции-обработчику. 
Допустим у нас есть функция, которая генерирует страницу со списком опубликованных статей
за указанный год и месяц:

    @http("/archive/$year/$month/articles")
    def articles(year, month):
        return "list of articles"

Задача — добавить в код страницы URL, указывающий на список статей за май 2009 года. Проанализировав шаблон URL мы можем
просто подставить значения в этот шаблон и получить URL '/archive/2009/5/articles'. Теперь мы можем добавить этот URL
в код страницы вручную. Однако, если впоследствии мы изменим шаблон для этой функции, нам нужно будет не забыть поменять
добавленный ранее вручную URL. Это не очень удобно, особенно если таких URL и мест, куда их нужно добавить много.
Для генерации URL в Пони используется функция `url`, которой передается
функция-обработчик и ее параметры.
Для нашего примера использование этой функции будет выглядеть следующим образом:

    url(articles, "2009", "5")

Здесь мы генерируем URL для функции-обработчика `articles`, поэтому указываем ее первым аргументом.
Затем указываются параметры функции `articles` в том же порядке, как их нужно указывать
при вызове самой функции `articles`.

Если мы выполним этот код в интерактивном режиме, то тут же увидим результат:    

    >>> from pony.main import *
    >>> @http("/archive/$year/$month/articles")
    ... def articles(year, month):
    ...     return "list of articles"
    ... 
    >>> url(articles, "2009", "5")
    "/archive/2009/5/articles"

Использование функции `url` для генерации URL позволяет менять структуру адресов веб-сайта,
не изменяя при этом сами функции, которые генерируют страницы.  

Функция `link` изпользуется для генерации ссылки в формате HTML:

    @webpage()
    def test():
        print "<html>"
        print link("Articles 05-2009", articles, "2009", "5") 
        print "</html>"

Первым параметром здесь указан текст, который будет отображаться на странице, затем идет
функция-обработчик страницы, на которую указывает ссылка и параметры, которые будут переданы
этой функции.
Результатом вызова функции `link` в этом примере будет такой HTML код:

    <a href="/archive/2009/5/articles">Articles 05-2009</a> 

Более подробно об использовании функции `link` можно почитать __здесь__



### Связывание URL с функцией-обработчиком в отдельном файле ###


В примерах, приведенных в этой главе, мы связываем URL с функцией-обработчиком с помощью декоратора
`@http`, который располагается непосредственно перед функцией. При этом сами функции могут находиться
в нескольких разных файлах. В некоторых фреймворках информация о роутинге выносится в отдельный файл.
Плюсом такого варианта является то, что зная URL, который нужно обработать и глядя на этот файл
легко можно сказать, где найти ту функцию, которая будет вызвана. Минусом вынесения информации о
роутинге в отдельный файл является то, что глядя на функцию-обработчик трудно сказать, как выглядит
URL, которую она обрабатывает.

Пони предоставляет возможность использовать любой из описанных подходов — выбор остается за
разработчиком. Рассмотрим на примере вариант вынесения функций в отдельный файл.

Допустим, у нас есть проект `myproject`, который состоит из двух модулей — `module1` и `module2`.
В отдельном файле нам нужно сначала импортировать компоненты Pony, среди которых содержится нужная нам функция `http`.
Затем импортировать функции-обработчики. В приведенном ниже примере мы делаем это двумя разными способами.
Далее в файле производится связывание функций-обработчиков с адресами на сайте: сначала указывается сама функция `http`,
затем в скобках записывается шаблон URL, затем в отдельных скобках указывается функция-обработчик.
Если для функции мы хотим построить URL по умолчанию, тогда URL не указывается — сразу после `http` идет функция-обработчик.

    from pony.main import *                     (1)
    from myproject.module1 import page1, page2  (2)
    from myproject import module2               (3)

    http(page1)                                 (4)
    http("/path")(page2)                        (5)
    http("/path/$x/$y")(module2.page3)          (6)

(1) Импортируем компоненты Pony стандартным способом.  
(2) Импортируем из модуля module1 только две функции-обработчика: page1 и page2.  
(3) Импортируем модуль module2.  
(4) Связываем функцию page1 с URL. Так как URL здесь не указан, он будет построен автоматически исходя из объявления функции page1.  
(5) Связываем функцию page2 с URL "path".  
(6) Связываем функцию page3 из модуля module2 с URL "/path/$x/$y".




### Переменное число аргументов ###


Если число параметров в URL заранее неизвестно, удобно воспользоваться возможностью передавать в функцию
произвольное число параметров:

    @http("/test/$x/$y/$*")
    def myfunction(x, y, *args):
        return "args=%s" % str(args)

*(переписать, учесть, что после может еще идти ? и после него аргументы)*
Запись `$*` сообщает Пони, что в этом месте в URL могут быть любые символы. Все они будут интерпретированы
как параметр `*args`. Указатель на переменное число параметров `$*` должен идти в шаблоне URL после всех переменных с разделителями.
После указателя на переменное число параметров может идти...

Если мы передадим такой URL на сервер "/test/ab/cd/ef/gh/xyz", то в результате переменным будут присвоены
следующие значения: x=ab, y=ef, args = ("ef", "gh", "xyz"). Здесь первая группа параметров `ab/cd` распределяется
между переменными `x` и `y` согласно заданному шаблону. Для параметра `*args` остается часть URL `ef/gh/xyz`, которая
представляется в виде кортежа ("ef", "gh", "xyz"). Для частей последнего аргумента разделителем всегда является символ "/".




### Редирект ###


Рассмотренная ранее возможность использования нескольких URL для одной и той же страницы
может быть удобна, если возникает необходимость введения новой структуры адресов для веб сайта.
Но вместе с удобством появляется неоднозначность. Пользователи не могут определить по внешнему виду какой адрес
старый, а какой новый. 
Поисковые машины присваивают бОльший рейтинг страницам с бОльшим числом линков на них. Если у одной и той же страницы
несколько адресов, то разные люди будут делать ссылки на разные адреса и это понизит эффективность веб-сайта.

Хорошей практикой считается иметь один постоянный URL для страницы. Если по какой-то причине нужно
сопоставить странице альтернативный URL, нужно обеспечить редирект с альтернативных адресов на
постоянный URL. Редирект - это автоматическая переадресация браузера на другой URL.
Для того, чтобы обеспечить редирект на новый адрес нужно указать `redirect=True` в декораторе со старым URL.
Для предыдущего примера это будет выглядеть так:

    @http("/archive/posts.php?year=$year&month=$month", redirect=True)
    @http("/archive/$year/$month/posts")
    def archive2(year=None, month=None):
        return "test"

Редирект может быть нескольких типов, самые часто используемые из которых - постоянный и временный.
По умолчанию, если указать параметр `redirect=True`, Пони делает постоянный редирект
с кодом "301 Moved Permanently".
Если поисковая машина натыкается на постоянный редирект, то отныне она будет обращаться сразу по новому адресу.
Временный редирект обозначается кодом "307 Temporary Redirect".
Если редирект временный, то поисковая машина не должна заменять старый адрес на новый.
Чтобы сделать временный редирект, или редирект какого то другого типа, нужно указать код редиректа
в качестве параметра:

    @http("/archive/$year-$month/posts", redirect="307 Temporary Redirect")

Другие возможные значения параметра `redirect` приведены __здесь___ (ссылка на routing-reference).




### Обработчики для конкретных HTTP методов ###


HTTP запрос может передаваться на сервер с помощью различных HTTP методов.
Самые распространенные из них - GET, POST, HEAD.
Когда мы объявляем функцию-обработчик с помощью декоратора @http,
то по умолчанию функция обрабатывает только эти три метода. Если от сервера придет запрос
с помощью другого метода, например PUT или DELETE, такой запрос обработан не будет 
и Пони сгенерирует страницу "404 Not Found".
Если вы хотите создать функцию-обработчик, которая должна обрабатывать другие HTTP методы,
нужно указать их явно. В примере приведенном ниже функция `test_delete` обрабатывает только запросы
HTTP методом DELETE: 

    @http.DELETE("/test")
    def test_delete():
        ...

В этом примере

    @http("/test")
    def test():
        return "methods GET, POST, HEAD"

Для всех трех методов - GET, POST, HEAD, будет вызвана функция `test`.
Если мы хотим, чтобы при обращении к одному и тому же URL для метода POST вызывалась одна функция,
а для GET и HEAD другая, нужно написать следующий код:

    @http("/test")
    def test_get_and_head():
        return "method GET and HEAD"

    @http.POST("/test")
    def test_post():
        return "method POST only"




### Автоматическое преобразование типа для переменных в URL ###


По умолчанию все параметры, которые извлекаются из URL, являются строками.
Иногда возникает необходимость определить обработчик, который принимает параметры 
какого-то иного типа.
Можно осуществить преобразование типа параметра внутри самой функции-обработчика, но существует и другой вариант.
Пони позволяет преобразовывать переменные при передаче в функцию-обработчик.
Ранее мы рассмотрели возможность указывать параметры функции по умолчанию.
В примере приведенном ниже, URL может содержать параметр `x`:

    @http("/test?x=$x")
    def test(x=1):
        ...

Если URL не содержит параметра `x`, то переменная `x` в функции получит значение по
умолчанию: 1. Указанное в этом примере значение по умолчанию числовое. Пони использует тип
параметра, заданного в обработчике по умолчанию для преобразования параметров, извлеченных из URL.
Поэтому, когда Пони получит URL с указанным значением парамера, например `/test?x=10`,
извлеченное из URL значение будет преобразовано к числовому типу и передано в функцию.
Если преобразование к типу параметра по умолчанию невозможно,
или при преобразовании произошел exception, Пони считает, что данная функция-обработчик
не подходит для этой URL. Например, при анализе такого URL `/test?x=foo`, указанная в примере
функция вызвана не будет.

Вместо значения по умолчанию в объявлении функции можно указать тип переменной, а также функцию,
которая будет служить конвертером.

    @http("/test?x=$x")
    def test(x=int):
        ...

Для такой функции Пони извлечет параметр `x` из URL и попытается конвертировать его к типу int.
Если конвертация прошла успешно, будет вызвана функция test, параметр `x` будет числового типа.
Если указанное значение по умолчанию является функцией, то данная функция рассматривается как конвертер,
который применяется к параметру, извлеченному из URL, и уже результат вызова функции передается
обработчику в параметре, например:

    @http("test/$x")
    def test(x=myfunction):
        ...

Использование значения по умолчанию в качестве типа параметра или конвертера не
является традиционным для Питона, и может кому-то не понравиться. Но такое
автоматическое преобразование типов перед вызовом функции освобождает пользователя
от необходимости делать это преобразование в функции-обработчике самому.
Кроме того, можно определять несколько похожих обрабочиков для URL, которые
отличаются только типом параметров. Сработает тот обработчик, конвертер которого
справился с преобразованием.




### Несколько похожих обработчиков ###


При сопоставлении URL функции-обработчику может возникнуть ситуация, когда URL соответствует
более чем одной функции. Например заданы две такие функции:

    @http("/mysite/$user")
    def user_page(user):
        ...

    @http("/mysite/login")
    def login_page():
        ...

Если, например, веб-браузер передал Пони URL `/mysite/login`, то формально этот URL подходит
обоим обработчикам. Если оказалось, что URL могут обработать несколько функций, Пони анализирует
какой функции URL подходит больше с помощью специального алгоритма. При выборе каждой функции
сопоставляется числовой рейтинг, который в свою очередь складывается из весов. Веса присваиваются за
совпадение между параметрами URL и шаблона, заданного в декораторе @http. При расчете рейтинга наибольший
вес дается за совпадение хоста, порта и метода, при условии если они заданы
в декораторе @http (критерии перечислены в порядке убывания весомости).
Затем Пони выбирает обработчик с максимальным рейтингом.
В приведенном выше примере, при обработке URL `/mysite/login`
будет выбран второй обрабочик, потому что Пони считает, что совпадение с
жестко заданным компонентом URL "login" - это более весомое соответствие,
чем совпадение с переменной $user.
Если URL подошла обработчику, в котором параметры отделены от других частей URL не слэшем,
а иными символами, это ценится выше, так как URL считается более специализированным.
Если после знака `?` в URL есть параметры, которые не совпадают с указанными в шаблоне декоратора @http,
считается, что он хуже подходит для данного URL, чем тот обработчик, которые знает об этих параметрах.
