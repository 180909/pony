URL Роутинг
===========

Назначение веб приложения - генерировать страницы, которые пользователь открывает в браузере.
Динамический веб сайт - это набор функций-обработчиков, которые вызываются в ответ
на набранные пользователем URL.
В этой главе мы рассмотрим модуль pony.routing, который отвечает за вызов соответствующих
функций-обработчиков и передачу необходимых параметров.

Модуль URL Роутинг решает две задачи:
    
  *  Преобразование URL в вызов конкретной функции-обработчика
  *  Генерация URL для конкретной функции-обработчика 

Преобразование URL в вызов конкретной функции-обработчика
---------------------------------------------------------
Основное назначение роутинга - связать набранный пользователем URL с
функцией-обработчиком на сервере.
Многие фреймворки используют регулярные выражения, чтобы сопоставить функцию для URL.
Регулярные выражения безусловно очень мощный инструмент, но вместе с этим часто трудный для
понимания для большинства пользователей.
Пони предлагает мощный и гибкий, в то же время простой для использования способ для решения этой
задачи, с которым мы познакомимся на нескольких простых примерах.

### Связывание URL с функцией-обработчиком ###
Процесс обработки URL выглядит следующим образом:
    
  1.  Пользователь набирает URL в браузере
  2.  URL запрос передается браузером на веб сервер  
  3.  Веб сервер передает запрос Пони  
  4.  Модуль URL роутинг анализирует запрос, находит соответствующий обработчик,
выделяет параметры из URL запроса и производит вызов функции-обработчика с этими параметрами

Давайте посмотрим как связать URL с функцией-обработчиком. Вот пример законченной программы,
которая генерирует страницу с помощью Пони.

    from pony.main import *     (1)

    @http                       (2)
    def hello():                (3)
        return "Hello world!"   (4) 

    http.start()                (5) 

(1) В первой строчке мы импортируем все самое необходимое для Пони. После того как выполнен
import мы можем использовать компоненты Пони в нашем коде.  
(2) Здесь мы _декорируем_ функцию hello с помощью декоратора http.  
Тем самым мы даем понять Пони, что мы хотим, чтобы эта функция была обработчиком для URL и
была бы доступна для пользователей веб сайта.  
(3) Объявление функции hello.  
(4) Возвращаемым значением будет строка "Hello world!".  
(5) Запускаем веб сервер. По умолчанию веб сервер обслуживает порт 8080. 
Как и все примеры, мы можем запустить этот пример из интерактивного режима и
посмотреть что получилось.  

После того как мы запустили приведенный выше код в интерактивном режиме или в виде отдельного файла,
мы можем посмотреть на сгенерированую страницу в браузере. Давайте разберемся, какой URL нужно
набрать, чтобы увидеть результат.
Когда мы указываем декоратор http без параметров, Пони по умолчанию строит URL используя имя самой функции.
В этом примере соответствующий этой функции URL будет '/hello'.
Наберем в браузере http://localhost:8080/hello и увидим наше приветствие.

    Картинка

Как вы видите из примера, связать URL с функцией-обработчиком в Пони очень просто.

### Передача параметров в функцию ###
На практике часто возникает необходимость передать параметры на сервер.
Самый простой способ сделать это в Пони - добавить необходимый параметр в функцию-обработчик:

    @http                                                     
    def hello(name):                              
        return "Hello " + name + "!"              

Здесь мы добавили в функцию параметр `name`, который тут же отображается на странице.

URL для этой страницы будет немного отличаться от предыдущего.
У функции hello теперь есть обязательный параметр. Раз этот параметр обязательный,
он должен присутствовать в URL. Поскольку мы не задали шаблон для URL,
Пони ожидает, что параметр будет указан в URL следующим способом:

    http://localhost:8080/hello?name=Pony

Если мы наберем этот URL в браузере, то увидим страницу, сгенерированную Пони:

    Картинка    

### Значения по умолчанию ###
Если нам нужно, чтобы у параметра было значение по умолчанию, нужно указать это в объявлении
функции:

    @http                                           
    def hello(name='world'):                 
        return "Hello %s!" % name   
                                  
Теперь, если мы не будем указывать ни одного параметра в URL, мы увидим, что Пони будет использовать
значение по умолчанию:

    Картинка

Мы также можем указать значение параметра в URL явно:    

    Картинка для http://localhost:8080/hello?name=Pony

Если внимательно присмотреться к последнему примеру, можно заметить, что здесь мы выводим
результат другим способом:

    return "Hello %s!" % name    

В этом примере `%s` определяет место, куда будет подставлен параметр `name`.

### Произвольные URL для функции-обработчика ###
До текущего момента мы не указывали никаких параметров для декоратора @http.
В таком режиме URL, по которому доступна функция строится по умолчанию.
Для нашего примера это будет

    /hello?name=some_name

Это стандартная запись для передачи параметров методом GET. Если мы хотим, чтобы URL был
более компактным и легко читаемым, нужно указать шаблон URL в декораторе `@http`.
В шаблоне мы указываем где располагается статическая и переменная часть URL. 
    
    @http('/hello/$name')                                           
    def hello(name):                 
        return "Hello %s!" % name

Здесь мы указали явно, что после символов `hello/` в URL ожидается переменная часть, которая будет
передана в функцию в качестве параметра `name`. Теперь нашей функции соответствует URL вида:

    /hello/Pony

    Картинка

Переменная часть, то есть параметр начианается с символа `$` и может состоять из символов,
которые разрешены для использования в идентификаторах в Питоне - буквы, цифры и знак подчеркивания.
Параметр может располагаться в любом месте URL. Например в середине:

    @http('/hello/$name/page.html')
    def hello(name):                 
        return "Hello %s!" % name    

Параметров может быть несколько:

    @http("/page/$a/$b/$c")
    def test(a, b, c):                 
        return "Hello, %s %s %s!" % (a, b, c)

Чтобы вывести несколько параметров, мы указали их места в строке с помощью символов `%s`.
Затем указали сами параметры в скобках согласно синтаксису Питона. 

Если мы хотим, чтобы параметры передавались обычным способом (после знака `?` в URL), мы можем это указать в шаблоне
таким способом:

    @http("/page?a=$a&b=$b")
    def test(a, b):                 
        return "Hello, %s %s!" % (a, b)

Переменными частями здесь будут `$a` и `$b`. В такой записи параметры сопоставляются именам переменных в самой URL,
поэтому их порядок в URL не важен. Например оба этих URL будут адресованы той же самой функции:

    /page?a=1&b=2
    /page?b=2&a=1

Случается ситуация, когда URL, который написан в декораторе отличается от того, который набран в
браузере только наличием или отсутствием знака '/' на конце.

Когда Пони анализирует URL полученный от браузера она сначала попытается найти точное соответствие.
Если точное соответствие есть - вызывается соответствующий обработчик.
Если точное совпадение не найдено, Пони попробует убрать/подставить слэш в конце URL (или перед знаком `?`) и найти
обработчик для такого URL. Если при этом найдено соответствие, Пони автоматически выполняет редирект
по найденному адресу. Таким образом для приведенных ранее примеров URL `/hello/Pony/`
будет автоматически переадресован на `/hello/Pony`, а `/page/?a=1&b=2` будет автоматически переадресован
на `/page?a=1&b=2`.

### Несколько URL для одного обработчика ###
Одной и той же функции-обработчику может быть сопоставлено несколько URL:

    @http('/hello?name=$name')
    @http('/hi/$name')                                           
    def hello(name='world'):                 
        return "Hello %s!" % name

При обработке первого указанного URL мы можем использовать либо имя заданное по умолчанию, либо станартную
передачу параметра в функцию:

    картинка для hello

    картинка для hello?name=Pony

Второй URL связанный с этой функцией отображает ту же самую страницу.

Иметь несколько постоянных URL для одной страницы считается плохим тоном. Мы остановимся на этой теме
подробно далее в этой главе, а сейчас просто сделаем переадресацию с одного URL на другой. Для этого добавим
в декоратор первого URL параметр `redirect=True`:

    @http('/hello?name=$name', redirect=True)
    @http('/hi/$name')                                           
    def hello(name='world'):                 
        return "Hello %s!" % name

Теперь, обращаясь к странице по URL `/hello?name=Pony`, мы автоаматически попадем на страницу `/hi/Pony`    

До текущего момента наши страницы генерировалась в виде простого текста.
Тип генерируемой страницы по умолчанию - `plain/text`.
Чтобы сгенерировать HTML страницу нам нужно просто указать параметр type='text/html' в декораторе:

    @http(type='text/html')
    def hello(name='world'):                 
        return "<h1>Hello %s!<h1>" % name   

Теперь страница выглядит совсем по другому:
    
    Картинка
    
Далее мы познакомимся с более удобными способами генерации HTML страниц.


Генерация URL для функции-обработчика
------------------------------------------------
............ описать больше примеров ..................
Допустим у нас есть функция с таким шаблоном
/mysite/$a/$b/$c/page.html

мы хотим сгенерировать адрес
/mysite/$a/$b/$c/page.html
Если бы мы открыли этот урл то Пони вызвала бы функци.
f1("100", "200". "300")
и результатом была бы сгенерированная страница.
чтобы получить адрес мы можем вызвать функци. url(f1, "100", "200", "300")
..................

Ранее мы познакомились с тем, как отображать URL на функцию-обработчик.
Часто при построении динамического веб сайта возникает обратная задача - отобразить
URL, который соответствует определенной функции-обработчику. Например, чтобы добавить сслыку
на раздел нашего сайта в главное меню. Конечно, зная какой URL соответствует фунции на данный момент,
можно просто вписать ее в HTML код. Но в этом случае каждое изменение URL потребует обновления
ранее указанной ссылки вручную.
Для генерации URL в Пони используется функция url, которой передается
функция-обработчик и ее параметры.

    url(func, arguments)  ............ убрать

Для примера попробуем отобразить URL для функции hello из последнего примера. Наберем в интерактивном режиме:

    >>> @http('/hi')
    ... @http('/hello/$name')                                           
    ... def hello(name='world'):                 
    ...    return "Hello %s!" % name
    ...
    >>> url(hello)
    '/hi'
    >>> url(hello, 'Pony')
    'hello/Pony'

Наличие удобного и гибкого роутинга позволяет менять структуру адресов веб сайта
не изменяя при этом сами функции, которые генерируют страницы. 

Более подробно о возможностях роутинга в Пони
=========================
Рассмотренных ранее возожностей вполне достаточно, чтобы построить веб сайт с помощью Пони.
В этом разделе мы рассмотрим возможности Пони, которые дают неограниченную свободу разработчику
оставаясь при этом максимально простыми для освоения, как и все компоненты Пони.

### Любые URL для функции-обработчика ###
Перед вами может стоять задача, когда URL должен соответствовать какой то
структуре, а параметры нужно передавать не поименно, а брать из самого URL.
Например для архива нашего сайта мы хотим, чтобы все статьи за Ноябрь 2008 года были бы доступны
по таком адресу:

    /archive/2008/11/posts

Решить такого рода задачу с помощью Пони очень просто. Для этого нам нужно указать Пони,
какая часть URL будет являться параметром:

    @http('/archive/$year/$month/posts')
    def archive(year, month):
        ...    

Каждый идентификатор, который начинается со знака '$' представляет собой динамическую часть URL.
Когда Пони сопоставляет URL с конкретной функцией-обработчиком, она выделяет динамические части из URL и
передает в функцию как параметры.

Разделителем между параметрами может быть не только символ '/'. Разделитель может быть практически любым символом
кроме буквы и цифры. Например

    >>> @http('/archive/$year-$month/posts')
    ... def archive2(year=None, month=None):
    ... 	return "archive2"
    ... 
    >>> url(archive2, 2008, 11)
    'archive/2008-11/posts'

### Несколько URL для одного обработчика ###
Ничто не остается постоянным и в какой то момент вам может понадобиться изменить структуру адресов веб сайта.
Используя возможности Пони это можно сделать довольно быстро, но нам нужно помнить, что некоторые пользователи
могли сделать закладки используя старые адреса. Если просто поменять URL страниц,
закладки, сделанные с использованием старых адресов, перестанут работать. 
Пользователи, которые приходят
на ваш веб сайт через поисковую машину тоже будут испытывать неудобства - пройдет какое то время
пока она перестроит индекс и заменит старые URL на новые.

Используя роутинг в Пони можно очень легко изменять структуру веб сайта,
не нарушая при этом работы тех пользователей, которые привыкли работать со старой структурой.
Любой фунции-обработчику можно присвоить сколько угодно URL адресов:

    >>> @http('/archive/posts.php?year=$year&month=$month')
    ... @http('/archive/$year/$month/posts')    
    ... def archive2(year=None, month=None):
    ... 	pass
    ...     

В этом примере пользователь получит ту же самую страницу открыв ее по двум разным URL. 

### Редирект ###
Использование нескольких URL для одной и той же страницы решает задачу введения новой структуры адресов.
Но вместе с удобством появляется неоднозначность. Пользователи не могут определить по внешнему виду какой адрес
старый, а какой новый. 
Поисковые машины присваивают бОльший рейтинг страницам с бОльшим числом линков на них. Если у одной и той же страницы
несколько адресов, то разные люди будут делать ссылки на разные адреса и это понизит эффективность веб сайта.

Хорошей практикой считается иметь один постоянный URL для страницы. Если по какой то причине нужно
сопоставить странице альтернативный URL, нужно обеспечить редирект с альтернативных адресов на
постоянный URL. Редирект - это автоматическая переадресация браузера на другой URL.
Для того, чтобы обеспечить редирект на новый адрес нужно указать `redirect=True` в декораторе со старым URL.
Для предыдущего примера это будет выглядеть так:

    >>> @http('/old-structure/archive/$year-$month/posts', redirect=True)
    ... @http('/new-structure/posts-archive/$year/$month/posts')    
    ... def archive2(year=None, month=None):
    ... 	pass
    ...      

Редирект может быть нескольких типов, самые часто используемые из которых - постоянный и временный.
По умолчанию, если указать параметр `redirect=True`, Пони делает постоянный редирект
с кодом '301 Moved Permanently'.
Если поисковая машина натыкается на постоянный редирект, то отныне она будет обращаться сразу по новому адресу.
Временный редирект обозначается кодом '307 Temporary Redirect'
Если редирект временный, то поисковая машина не должна заменять старый адрес на новый.
Чтобы сделать временный редирект, или редирект какого то другого типа, нужно указать код редиректа
в качестве параметра:

    @http('/old-structure/archive/$year-$month/posts', redirect='307 Temporary Redirect')

Другие возможные значения параметра `redirect` приведены ниже.

### Параметры декоратора http ### 
Декоратор http может принимать несколько параметров: url, host, port, redirect, headers.
Все параметры необязательные.

`url`  
Задает URL, который будет обрабатываться этой функцией. Параметр может включать в себя следующие части

  *  Статические части. Требуется полное совпадение между указанной статической частью и соответствующей
  частью полученного URL
  *  Параметры. Параметр начианается с символа `$` и может состоять из символов, которые разрешены для
  использования в идентификаторах в Питоне.
  * wildcard. Запись `$*` соответствует любому набору символов начиная с этого места и до конца URL
.............. добавить раздел, который расписывает эту возможность
URL с произвольным числом параметров

Пример

  @http('/events/archive/$year/$month/posts')
         |              |     |      | статическая часть
        статическая часть  параметр1
                                           параметр2
`host`  
Когда веб сервер передает запрос приложению, в запросе указывается какому хосту и порту предназначается вызов

    URL: http://localhost:8080/hello
                 host     port

Если приложение обслуживает несколько хостов, то в этом параметре можно указать какой хост обслуживает эта функция.
По умолчанию, когда не указано никакое значение, обслуживаются все хосты.
В этом параметре можно указать сразу и хост и порт, например:

    @http(host='localhost:8080')
    def hello():
        return 'Hello world!'

Эта функция будет обрабатывать только те запросы, которые были адресованы хосту localhost и порту 8080.
Если веб сервер работает еще например на порту 80 и пользователь обратиться на этот порт, то
такой запрос не будет обработан этой функцией.

`port`
Если приложение обслуживает несколько портов, например localhost:80 и localhost:8080, то можно указать
какой конкретный порт обслуживает эта функция. По умолчанию, если ничего не указывать в качестве значения,
обслуживаются все порты, на которых запущен веб сервер.

`redirect`  
Этот параметр определяет будет ли осуществляться редирект с указанного URL.
Значение по умолчанию - `False`, редирект не выполняется.
Другие значения этого параметра будут приводить к редиректу.
Редирект будет произведен на постоянный URL, указанный для этой же функции-обработчика
(URL для которого не задан параметр `redirect`).
Хорошим тоном является наличие у страницы только одного постоянного URL.
Возможные значения этого параметра - стандартные коды редиректа для HTTP:

    '301 Moved Permanently'
    '302 Found'
    '303 See Other'
    '305 Use Proxy'
    '307 Temporary Redirect'

Значение параметра `True` эквивалентно коду '301 Moved Permanently'
Для этого параметра возможна короткая запись. Если указать только числовое значение кода,
оно будет преобразовано к полной стандартной записи.
Например:

    @http('/new-hello')
    @http('/old-hello', redirect=307)
    def hello():
        return 'Hello world!'
    
Обращение к URL '/old-hello' приведет к редиректу на URL '/new-hello' с кодом '307 Temporary Redirect'

`**headers`  
Если возникает необходимость установить какие то определенные заголовки при генерации страницы,
можно указать их в качестве поименных параметров в декораторе `@http`:
    
    @http('/test', foo_bar='123')
    def myfunction():
        return 'hello'

результатом будет страница, в которой будет установлен заголовок `Foo-Bar` со значением `123`.
Символ подчеркивания в имени заголовка заменяется на `-`, а каждая часть имени начинается с заглавной буквы:

    200 OK
    Content-Type: text/plain
    Foo-Bar: 123

Это возможность удобно использовать, если нам нужно указать тип генерируемого функцией контента или кодировку:
    
    @http(content_type="text/foobar; charset=koi8-r")    
    def test():
        return 'test'
 
Результатом будет страница, в которой установлен заголовок
Content-Type: text/foobar; charset=koi8-r

Часто пользователям удобно указывать MIME тип и кодировку по отдельности. Эта возможность поддерживается в Пони:

    @http(content_type="text/foobar", charset="koi8-r")
    def test():
        return 'test'

По умолчанию, если не задан type, его значением будет `text/plain`,
а значение `charset=UTF-8`

### Обработчики для конкретных HTTP методов ###
HTTP запрос может передаваться на сервер с помощью различных HTTP методов.
Самые распространенные из них - GET, POST, HEAD.
Когда мы объявляем функцию-обработчик с помощью декоратора `http`,
то по умолчанию функция обрабатывает только эти три метода. Если от сервера придет запрос
с помощью другого метода, например PUT или DELETE, такой запрос не будет обработан
и Пони сгенерирует страницу '404 - Not Found'.
Чтобы указать Пони, что функция обрабатывает другие методы нужно указать их явно:

    @http.DELETE
    def test():
        ... some code here ...



Обычная запись
@http -
При этом обрабатываются только методы
HEAD, GET, POST
Но не будет обработаны другие методы (такие как PUT, DELETE, etc)
Если наряду с общим обработчиком указан и специфический, например
@http.GET
То Пони перенаправит GET запрос обработчику @http.GET
а POST и HEAD общему.


### Несколько похожих обработчиков ###

@http("/test/$x/abcd")
def test1(x)
 
@http("/test/$a/$b")
def test2(a, b)

/test/333/abcd - first one
/test/333/abce - second one

### Переменное число аргументов ###

@http("/test/$x/$y/$*")
def myfunction(x, y, *args)
/test/ab/cd/ef/gh -> $x=ab, $y=ef, args = ("ef", "gh")
 

### Числовой тип парамера для переменной в URL ###
Тип всех переменных, которые извлекаются из URL имеет строковый тип (str).
Иногда бывает удобно указать, что в функции ожидается числовое значение.
При сопоставлении URL с функцией Пони преобразует отмеченные переменные к числовому типу.
Если преобразование невозможно, Пони считает, что эта функция не совпадает с URL.
Например:

    @http("test/$x/$y")
    def test(x=int, y):
        return "test"

Обращение к URL '/test/100/200' будет преобразована к вызову функции `test` с параметрами x=100, y='200'.
Обращение к URL '/test/abc/def' в результате приведет к отображению страницы 'Not Found'




......... переместить и убрать раздел .................
### Страница 404 - Not Found ###
В случае, если Пони не находит ни одного соответствия URL с функцией-обработчиком, генерируется страница с HTTP
кодом 404 - Not Found.
В режиме отладки на эту страницу выводится список всех зарегистрированных URL.
Когда разработка веб сайта завершена и сайт запущен в production, следует выключить вывод отладочных сообщений.
Файл pony/options.py среди прочих параметров содержит параметр

    DEBUG = True

который определяет режим отображения отладочных сообщений.

