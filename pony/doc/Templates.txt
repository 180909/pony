Шаблоны
=======


Шаблоны предназначены для генерации любых текстовых документов, в том числе HTML страниц.
Шаблон содержит статическую часть документа
и места, куда подставляются значения на этапе генерации документа.
Также в шаблоне могут присутствовать простые логические операторы, которые срабатывают во время
генерации документа.


Шаблон это документ, в котором обозначены места, куда нужно подставить значения переменных.
Шаблон может содержать простую логику, например для вывода данных таблицы в цикле.

Простейший пример шаблона:

    >>> from pony.main import *         (1)
    >>> def test():                     (2)
    ...     name = "world"              (3)
    ...     return html("Hello $name")  (4)
    ...    
    >>> test()                          (5)
    Html(u'Hello world')                (6)
    >>>

*** может вместо return использовать print?  тогда не будет Html(u'...'), а сам текст ***

В этом примере происходит следующее
(1) Импортируем все необходимые компоненты Пони.  
(2) Объявляем функцию test.  
(3) Объявляем переменную name и присваиваем ей значение "world".  
(4) При возврате результата функции test вызывается функция html, которая обрабатывает
заданный шаблон "Hello $name".  
(5) Здесь мы вызываем функцию test, которая генерирует результат (6) - Html объект, который
состоит из строки 'Hello world'. Буква u перед строкой указывает, что это unicode строка.


В этом примере в шаблоне используется переменная name, которая объявлена в функции.
В шаблоне можно использовать любые питоновские выражения, а также функции, которые доступны из модуля,
в котором объявлен шаблон. Чтобы дать понять Пони, что это не статическая часть, нужно использовать
символ $ перед переменной, функцией или выражением. Если в тексте нужно указать сам символ $,
то нужно написать этот символ дважды: $$.
Если выражение состоит из нескольких переменных или включает в себя операции, нужно взять это
выражение в скобки, а перед скобками поставить символ $.
Рассмотрим другой пример

    >>> def test2():
    ... 	a = 5
    ... 	b = 10
    ... 	return html("$a + $b = $(a + b)")
    ... 
    >>> test2()
    Html(u'5 + 10 = 15')
    >>> 

В этом примере сначала выводится значение каждой переменной по отдельности, а затем вычисляется сумма.
Из шаблона может быть вызвана любая функция, которая доступна из самого модуля.
Это может быть стандартная функция из питоновской библиотеки, или объявленная в модуле функция:

    >>> def test3():
    ... 	string1 = 'letters'
    ... 	return html("string1 = $string1; len(string1) = $len(string1)")
    ... 
    >>> test3()
    Html(u'string1 = letters len(string1) = 7')

Возможность вызывать функции из шаблона позволяет удобно конструировать документы любой сложности,
создавая большой документ из более мелких кусочков:

    >>> def header():
    ... 	return html("This is the header")
    ... 
    >>> def body(name):
    ... 	return html("Hello $name")
    ... 
    >>> def footer():
    ... 	return html("This is the footer")
    ... 
    >>> def page():
    ... 	return html("""
    ... $header
    ... $body("world")
    ... $footer""")
    ...     
    >>> print page()

    This is the header
    Hello world
    This is the footer
    >>> 

Этот пример демонстрирует возможность создавать документ из частей. 

### Сохранение шаблонов в html файлах
Ранее мы рассмотрели примеры, в которых задавали шаблон в качестве параметра функции html.
Если размер шаблона больше нескольких строк, то удобнее хранить его в отдельном файле.
В этом случае в функции нужно сделать вызов ф
Для больших шаблонов есть более удобный способ - шаблон находится в отдельном файле,
а в функции делается вызов функции html без параметров.


### Синтаксис
$имя_переменной
после имени может быть
$имя.атрибут
$имя[индекс или ключ]
$имя(парметры)
во всех случаях это выполняется как питоновское выражение
когда мы пишем так они выполняются в рамках питоновского контекста
можно писать так $(x+y)
но $(x + y).attr $(x + y)[key] - работать не будет

$имя;[abc], abc - уже не часть выражения
; - принудительное окончание выражения

если идут скобки, предполагается что после них выражение закончилось
$a.b.c(d, e, f).g.h
.g.h не является частью выражения
то же относится и к []
$a.b.c[d, e, f].g.h

Допустим
$a.b.c[d, e, f].g.h

после a.b выражение прерывается
тогда мы пишем $(a.b).c(d, e, f).g.h
или
$a.b;.c(d, e, f).g.h
; будет съедена
если хотим, чтобы была нужно написать ее дважды
$a.b;;.c
первая ; это выражение, другая это текст

Кроме переменных и функций в шаблоне можно использовать директивы.
Директивы позволяют управлять логикой постороения шаблона.
Все директивы выполняются на этапе генерации шаблона.

### Условный оператор
Условный оператор позволяет подставить ту или иную часть документа на этапе генерации, в зависимости
от условия. Логика работы такая же как у условного оператора в Питоне.

    $if(условие){разметка1}
    $elif(условие2){разметка2}
    $else{разметка3}

__добавить пример__

### Оператор цикла
Оператор цикла удобен при выводе повторяющихся строк, например таблицы.

$for(a, b, c in expression) { разметка }
эти переменные доступны только в самом цикле
потом будут удалены
если такие переменные существовали в программе, им будут восстановлены предыдущие значения


$for(a in expr1) {
   $a - из expr1
   $for(a in expr2) {
      $a - expr2
   }
   $a - expr1
}

в обычном питоне не так, если переменную заменили, то она остается измененной
внутри шаблонов нет никаких side-effects

Оператор цикла в шаблоне позволяет объявлять дополнительные переменные
$for(a, b in expr; c = a + 1; d = a * b) {
  $a $b $c $d
}

a, b in expr; - для итераций
c = a + 1; d = a * b - доп переменные, которые создается на каждом витке цикла

$for(a in expr)
{
    разметка1
)
$else
{
   разметка2
}

else выполняется если не был выполнен ни один виток цикла (в питоне если все витки цикла были выполнены без break, то есть до конца)

### Использование разделителя
$separator

$for(a, b in expr)
{
  ...
}
$separator{ ... }
$else{ ... } - послушать запись

------------
$for(a, b in expr) {
  ...
}

$for(a, b in expr)
{
  ...
}
мы поглащаем некоторые переводы строк, надо проэкспериментировать (наверное после первой фигурной скобки)



### Обработка исключений в шаблонах

try ... except

$try{  <<< $(a/b) >>>  }
$except(Exception1){ ... }
$except(Exception2){ ... }
$else{ ... } - надо проверить есть ли else

$try{  ... }
$except(Exception1){ ... }
$except(Exception2){ ... }
$except{ ... }

более короткая запись
$( ... ){ ... }

$(a/b){извините, произошла ошибка}, выполнение шаблона при этом не прервется


### Вызов функций

если мы создали в питоне функцию
def myfunction(a, b, c):
   ...

в шаблоне $myfunction(x, y, z) сделает вызов и подставит результат

$myfunction(x, y){ ... } - передать разметку, третий аргумент

$myfunction(x){ ... }{ ... }

$myfunction{ ... }{ ... }{ ... }
получает 3 разметки

$cycle{ ... }{ ... }{ ... }

есть три дырки на странице
$mylayout{ header }{ body }{ footer }

Например:
def div(x):
    return html('<div class="myclass">$x</div>')

$div{ <h1>Hello, $name!</h1> }
результат будет
<div class="myclass"><h1>Hello, John!</h1></div>

### Оператор IF

def IF(p, q):
  if p: return q
  else: return ""

$IF(a<b){ a меньше чем b}

$IF(a<b){ $a меньше чем $b!!! }
если a = 10, b = 20, на экран будет вываедено "10 меньше чем 20"

отличие IF от if в том, что сначала выполнится разметка

$if( b != 0){ Результат $(a/b) }

обычный иф выполнит a/b только если b!=0, а IF - сначала выполнит разметку, то есть a/b

def IF(p, q):
  if p: return q.eval()
  else: return ""

IF.lazy = True  - полностью имитирует обычный if

@lazy
def IF(p, q):
  if p: return q.eval()
  else: return ""

i18n

---------------


from pony.templating import html

class Layout(object):
    def header(self, markup):
        self._header = markup
    def footer(self, markup):
        self._footer = markup
    def __str__(self):
        return html('''
            <div>
              <h1>$(self._header)</h1>
              <h2>$(self._footer)</h2>
            </div>
            ''')
    
print html("""

$Layout()
$.header{<strong>This is header</strong>}
$.footer{<em>This is footer</em>}

$Layout()
$.header{<strong>This is header</strong>}
$.footer{<em>This is footer</em>}

""")

$.header - метод предыдущего объекта, который был создан
str генерируется неявно