Шаблоны
=======


Шаблоны предназначены для генерации любых текстовых документов, в том числе HTML страниц.

Обычно для генерации страницы веб-приложение выполняет код для обращения к базе данных, код логики приложения и
код для генерации HTML страницы - презентации данных. Если весь этот код держать вместе, в одной функции, получается
код, который трудный для чтения и изменения.
Шаблоны позволяют разделить бизнес логику приложения и логику презентации данных.

Шаблон может содержать:
  * Текст, который выводится при генерации документа без изменений.
  * Места (placeholders), куда подставляются значения переменных на этапе генерации документа.
  * Логические операторы, которые срабатывают во время генерации документа, чтобы сгенерировать тот или иной текст
(условный операторы, операторы цикла и др.).
  * Вызовы других шаблонов
  * Обращения к любым функциям Питона



### Использование функции template


Для генерации текстовых документов используется функция template.   
Простейший пример шаблона:

    >>> from pony.main import *              (1)
    >>> def test(name):                      (2)
    ... 	return template("Hello $name!")  (3)
    ... 
    >>> print test("world")                  (4)
    Hello world!                             (5)

В этом примере происходит следующее:
(1) Импортируем все необходимые компоненты Пони.  
(2) Объявляем функцию test с параметром name.
(3) При возврате результата функции test вызывается функция template, которая обрабатывает
заданный шаблон "Hello $name!".
(4) Здесь мы вызываем функцию test с параметром "world". Результат - строка unicode "Hello world!",
которая выводится в следующей строке (5)

Пони позволяет обращаться из шаблона к любой переменной, которая доступна в функции. 
В шаблоне можно использовать любые питоновские выражения, а также функции, которые доступны из модуля,
в котором объявлен шаблон. Чтобы дать понять Пони, что это обращение к переменной или функции, нужно использовать
символ $ перед переменной, функцией или выражением. Если в тексте нужно указать сам символ $,
то нужно написать этот символ дважды: $$.
Если выражение состоит из нескольких переменных или включает в себя операции, нужно взять это
выражение в скобки, а перед скобками поставить символ $.
Рассмотрим другой пример:

    >>> def test2():
    ... 	a = 5
    ... 	b = 10
    ... 	return template("$a + $b = $(a + b)")
    ... 
    >>> print test2()
    5 + 10 = 15
    
В этом примере сначала выводится значение каждой переменной по отдельности, а затем вычисляется сумма.
Из шаблона может быть вызвана любая функция, которая доступна из самого модуля.
Это может быть стандартная функция из питоновской библиотеки, или  функция, объявленная в модуле:

    >>> def test3():
    ... 	s = 'abcdef'
    ... 	return template("s = $s, len(s) = $len(s)")
    ... 
    >>> print test3()
    s = abcdef, len(s) = 6
    
Возможность вызывать функции из шаблона позволяет удобно конструировать документы любой сложности,
создавая большой документ из более мелких частей:

    >>> def header():
    ... 	return template("This is the header")
    ...
    >>> def body(name):
    ...     return template("Hello $name!")
    ...
    >>> def page():
    ... 	return template("""
    ... $header
    ... $body("world")
    ... """)
    ...     
    >>> print page()

    This is the header
    Hello world!




### Использование функции html


Для генерации HTML страниц, вместо функции template, следует использовать функцию html.
Функция html во всем аналогична функции template, за одним исключением - при передаче параметра в шаблон,
Пони переводит все небезопасные символы в escape последовательности для предотвращения XSS аттак.
Давайте рассмотрим вышесказанное на примере:

    >>> def hello(name):
    ...  return html('<H1>Hello, $name!</H1>')
    ... 
    >>> print hello('John')
    <H1>Hello, John!</H1>

Часто для генерации страницы веб-приложение использует информацию, полученную от пользователей.
XSS атака заключается в том, то хакер может передать javascript код, под видом запрашиваемой информации, который
потом будет исполнен на компьютере любого пользователя, открывшего эту же страницу.
Использование функции html позволяет защититься от такого рода атаки. Таким образом, если хакер попытается передать
код на сервер, этот код будет отображен на странице как текст:

    >>> print hello("<script>alert('Evil script!')</script>")
    <H1>Hello, &lt;script&gt;alert(&#39;Evil script!&#39;)&lt;/script&gt;!</H1>

Если внутри программы нам самим нужно передать HTML код в качестве параметра, для этой цели нужно использовать функцию
html:
                                   
    >>> print hello(html('<b>not escaped</b>'))
    <H1>Hello, <b>not escaped</b>!</H1>

Таким образом, все что указывается внутри функции html считается HTML разметкой и с этим текстом не производится никаких преобразований.
Параметры, которые передаются в шаблон, автоматически проходят через преобразование символов HTML разметки в их текстовое представление.  




Шаблон может содержать простую логику, например для вывода данных таблицы в цикле.
__пример__



объяснить чем отличается printhtml от html



Может быть убрать этот пример или перенести его или придумать попроще


### Сохранение шаблонов в html файлах
Ранее мы рассмотрели примеры, в которых задавали шаблон в качестве параметра функции html.
Если размер шаблона больше нескольких строк, то удобнее хранить его в отдельном файле.
В этом случае в функции нужно сделать вызов ф
Для больших шаблонов есть более удобный способ - шаблон находится в отдельном файле,
а в функции делается вызов функции html без параметров.


### Синтаксис
$имя_переменной
после имени может быть
$имя.атрибут
$имя[индекс или ключ]
$имя(парметры)
во всех случаях это выполняется как питоновское выражение
когда мы пишем так они выполняются в рамках питоновского контекста
можно писать так $(x+y)
но $(x + y).attr $(x + y)[key] - работать не будет

$имя;[abc], abc - уже не часть выражения
; - принудительное окончание выражения

если идут скобки, предполагается что после них выражение закончилось
$a.b.c(d, e, f).g.h
.g.h не является частью выражения
то же относится и к []
$a.b.c[d, e, f].g.h

Допустим
$a.b.c[d, e, f].g.h

после a.b выражение прерывается
тогда мы пишем $(a.b).c(d, e, f).g.h
или
$a.b;.c(d, e, f).g.h
; будет съедена
если хотим, чтобы была нужно написать ее дважды
$a.b;;.c
первая ; это выражение, другая это текст

Кроме переменных и функций в шаблоне можно использовать директивы.
Директивы позволяют управлять логикой постороения шаблона.
Все директивы выполняются на этапе генерации шаблона.

### Условный оператор
Условный оператор позволяет подставить ту или иную часть документа на этапе генерации, в зависимости
от условия. Логика работы такая же как у условного оператора в Питоне.

    $if(условие){разметка1}
    $elif(условие2){разметка2}
    $else{разметка3}

__добавить пример__

### Оператор цикла
Оператор цикла удобен при выводе повторяющихся строк, например таблицы.

$for(a, b, c in expression) { разметка }
эти переменные доступны только в самом цикле
потом будут удалены
если такие переменные существовали в программе, им будут восстановлены предыдущие значения


$for(a in expr1) {
   $a - из expr1
   $for(a in expr2) {
      $a - expr2
   }
   $a - expr1
}

в обычном питоне не так, если переменную заменили, то она остается измененной
внутри шаблонов нет никаких side-effects

Оператор цикла в шаблоне позволяет объявлять дополнительные переменные
$for(a, b in expr; c = a + 1; d = a * b) {
  $a $b $c $d
}

a, b in expr; - для итераций
c = a + 1; d = a * b - доп переменные, которые создается на каждом витке цикла

$for(a in expr)
{
    разметка1
)
$else
{
   разметка2
}

else выполняется если не был выполнен ни один виток цикла (в питоне если все витки цикла были выполнены без break, то есть до конца)

### Использование разделителя
$separator

$for(a, b in expr)
{
  ...
}
$separator{ ... }
$else{ ... } - послушать запись

------------
$for(a, b in expr) {
  ...
}

$for(a, b in expr)
{
  ...
}
мы поглащаем некоторые переводы строк, надо проэкспериментировать (наверное после первой фигурной скобки)



### Обработка исключений в шаблонах

try ... except

$try{  <<< $(a/b) >>>  }
$except(Exception1){ ... }
$except(Exception2){ ... }
$else{ ... } - надо проверить есть ли else

$try{  ... }
$except(Exception1){ ... }
$except(Exception2){ ... }
$except{ ... }

более короткая запись
$( ... ){ ... }

$(a/b){извините, произошла ошибка}, выполнение шаблона при этом не прервется


### Вызов функций

если мы создали в питоне функцию
def myfunction(a, b, c):
   ...

в шаблоне $myfunction(x, y, z) сделает вызов и подставит результат

$myfunction(x, y){ ... } - передать разметку, третий аргумент

$myfunction(x){ ... }{ ... }

$myfunction{ ... }{ ... }{ ... }
получает 3 разметки

$cycle{ ... }{ ... }{ ... }

есть три дырки на странице
$mylayout{ header }{ body }{ footer }

Например:
def div(x):
    return html('<div class="myclass">$x</div>')

$div{ <h1>Hello, $name!</h1> }
результат будет
<div class="myclass"><h1>Hello, John!</h1></div>

### Оператор IF

def IF(p, q):
  if p: return q
  else: return ""

$IF(a<b){ a меньше чем b}

$IF(a<b){ $a меньше чем $b!!! }
если a = 10, b = 20, на экран будет вываедено "10 меньше чем 20"

отличие IF от if в том, что сначала выполнится разметка

$if( b != 0){ Результат $(a/b) }

обычный иф выполнит a/b только если b!=0, а IF - сначала выполнит разметку, то есть a/b

def IF(p, q):
  if p: return q.eval()
  else: return ""

IF.lazy = True  - полностью имитирует обычный if

@lazy
def IF(p, q):
  if p: return q.eval()
  else: return ""

i18n

---------------


from pony.templating import html

class Layout(object):
    def header(self, markup):
        self._header = markup
    def footer(self, markup):
        self._footer = markup
    def __str__(self):
        return html('''
            <div>
              <h1>$(self._header)</h1>
              <h2>$(self._footer)</h2>
            </div>
            ''')
    
print html("""

$Layout()
$.header{<strong>This is header</strong>}
$.footer{<em>This is footer</em>}

$Layout()
$.header{<strong>This is header</strong>}
$.footer{<em>This is footer</em>}

""")

$.header - метод предыдущего объекта, который был создан
str генерируется неявно