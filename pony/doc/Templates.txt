Шаблоны
=======


Шаблоны предназначены для генерации любых текстовых документов, в том числе HTML страниц.

Обычно для генерации страницы веб-приложение выполняет код для обращения к базе данных,
код логики приложения и код для генерации HTML страницы.
Если весь этот код держать вместе, в одной функции, то текст программы становится труден для чтения и изменения.
Шаблоны позволяют разделить логику веб-приложения и логику генерации HTML страниц.

Особенностью шаблонов в Пони является то, что внутри них можно использовать произвольные выражения языка Питон,
в том числе вызовы функций (как стандартных, так и определенных пользователем).



### Использование функции template


Для генерации текстовых документов используется функция template.   
Простейший пример шаблона:

    >>> from pony.main import *              (1)
    >>> def test(name):                      (2)
    ... 	return template("Hello $name!")  (3)
    ... 
    >>> print test("world")                  (4)
    Hello world!                             (5)

В этом примере происходит следующее:
(1) Импортируем все необходимые компоненты Пони.  
(2) Объявляем функцию test с параметром name.
(3) При возврате результата функции test вызывается функция template, которая обрабатывает
заданный шаблон "Hello $name!".
(4) Здесь мы вызываем функцию test с параметром "world". Результат - строка unicode "Hello world!",
которая выводится в следующей строке (5)

Пони позволяет обращаться из шаблона к любой переменной, которая доступна в функции. 
В шаблоне можно использовать любые питоновские выражения, а также функции и объекты, которые доступны из модуля,
в котором объявлен шаблон. Чтобы дать понять Пони, что это обращение к переменной или функции, нужно использовать
символ $ перед переменной, функцией или выражением. Если в тексте нужно указать сам символ $,
то нужно написать этот символ дважды: $$.
Если выражение состоит из нескольких переменных или включает в себя операции, нужно взять это
выражение в скобки, а перед скобками поставить символ $.
Рассмотрим другой пример:

    def test2():
     	a = 5
     	b = 10
     	return template("$a + $b = $(a + b)")

Результатом вызова "print test2()" будет такой:

    print test2()
    5 + 10 = 15
    
В этом примере сначала выводится значение каждой переменной по отдельности, а затем вычисляется сумма.
Из шаблона может быть вызвана любая функция, которая доступна из самого модуля.
Это может быть стандартная функция из питоновской библиотеки, или  функция, объявленная в модуле:

    def test3():
    	s = 'abcdef'
    	return template("s = $s, len(s) = $len(s)")
    
    print test3()
    s = abcdef, len(s) = 6
    
Возможность вызывать функции из шаблона позволяет удобно конструировать документы любой сложности,
создавая большой документ из более мелких частей:

    def header():
     	return template("This is the header")
    
    def body(name):
        return template("Hello $name!")

    def page():
        return template(
            """
            $header
            $body("world")
            """)
         
Результатом вызова "print page()" будет:

    This is the header
    Hello world!



### Использование функции html


Для генерации HTML страниц, вместо функции template, следует использовать функцию html.
Эта функция поддерживает концепцию безопасных строк описанную ранее в разделе [Генерация HTML](HtmlGeneration).
Текст, который содержится внутри шаблона является безопасной строкой.
При передаче в шаблон небезопасной строки, Пони переводит все небезопасные символы в escape
последовательности для предотвращения XSS аттак. Давайте рассмотрим вышесказанное на примере:

    >>> def hello(name):
    ...  return html('<H1>Hello, $name!</H1>')
    ... 
    >>> print hello('John')
    <H1>Hello, John!</H1>

Часто для генерации страницы веб-приложение использует информацию, полученную от пользователей.
XSS атака заключается в том, то хакер может передать javascript код, под видом запрашиваемой информации, который
потом будет исполнен на компьютере любого пользователя, открывшего эту же страницу.
Использование функции html позволяет защититься от такого рода атаки. Таким образом, если хакер попытается передать
код на сервер, этот код будет отображен на странице как текст:

    >>> print hello("<script>alert('Evil script!')</script>")
    <H1>Hello, &lt;script&gt;alert(&#39;Evil script!&#39;)&lt;/script&gt;!</H1>

Если внутри программы нам самим нужно передать HTML код в качестве параметра, для этой цели нужно использовать
безопасную строку. Например, полученную с помощью той же функции html:
                                   
    >>> print hello(html('<b>not escaped</b>'))
    <H1>Hello, <b>not escaped</b>!</H1>

Таким образом, все что указывается внутри функции html считается HTML разметкой и с этим текстом не производится
никаких преобразований. Параметры, которые передаются в шаблон, автоматически проходят через преобразование
символов HTML разметки в их текстовое представление, если они еще не являются безопасными строками (экземплярами
класса Html)




### Сохранение шаблонов в html файлах


Ранее мы рассмотрели примеры, в которых задавали шаблон в качестве параметра функции html.
Если размер шаблона больше нескольких строк, то удобнее хранить его в отдельном файле.
Имя файла с шаблоном нужно указать функции html() в качестве параметра filename:

    def hello(name):
        return html(filename = "template1.html")

    Содержимое файла "template1.html":
    <H1>Hello, $name!</H1>

Путь к файлу может быть относительным (относительно главного запускаемого файла приложения),
либо абсолютным.

    filename = "templates/template1.html"

    filename = "C:\\website\\template1.html"

Вместо двойного обратного слэша в Windows можно использовать одинарный прямой:

    filename = "C:/website/template1.html"

Если не указывать параметр filename для функции html(), Пони будет искать шаблон в файле, имя которого
формируется следующим образом:

    имя_модуля.имя_функции.html    

Например, файл example1.py содержит функцию page(), из которой производится вызов html().
В этом случае Пони откроет шаблон, который находится в файле example1.page.html




### Интернационализация


Подробно возможности интернационализации описаны в соответствующем [разделе](I18n.txt).
Здесь мы упомянем для полноты картины, что в имени файла может фигурировать язык:

        имя_модуля.имя_функции-язык.html    
        
Например:

    example1.page8-en.html
    example1.page8-ru.html

Таким образом, если в HTTP запросе предпочтительным языком указан русский, то Пони попытается открыть
шаблон из файла example1.page8-ru.html




### Использование выражений


Пони позволяет обращаться к любому объекту, функции, переменной, которая доступена в функции, из которой производится вызов шаблона.
По сути, в шаблоне можно написать любое питоновское выражение. Чтобы дать понять Пони, что это питоновское выражение,
нужно поставить перед ним символ $:

    $имя_переменной
    $имя_функции

Выражение может включать в себя обращение к атрибуту переменной, индексу или ключу, параметрам функции:

    $имя.атрибут
    $имя[индекс или ключ]
    $имя_функции(параметры)

Во всех описанных выше случаях приведенная конструкция будет считаться питоновским выражением и будет выполнена в рамках
контекста функции, из которой произведен вызов шаблона.
Если нам нужно записать выражение, то его следует взять в скобки:

    $(x+y)

Когда скобки закрываются, Пони считает, что заканчивается и выражение. В следующих примерах питоновское выражение заканчивается
после закрывающей скобки:
    
    $(x + y).attr     
    $(x + y)[key]

В этих примерах .attr и [key] уже не относится к выражению и будет отображено в генерируемом документе как текст.
Чтобы выражение было все целиком, нжуно включить его в еще одни скобки:

    $((x + y).attr)     
    $((x + y)[key])

Теперь .attr и [key] тоже относится к выражению.

Таким образом, если в выражении используются скобки, то выражение заканчивается как только закрываются скобки:    

    $a.b.c(d, e, f).g.h

Здесь .g.h уже не является частью выражения. То же относится и к квадратным скобкам:

    $a.b.c[d, e, f].g.h

Здесь .g.h уже не является частью выражения.

В приведенном ниже примере выражением является только a.b:
 
    $(a.b).c(d, e, f).g.h

Если нам нужно принудительно завершить выражение, для этого следует использовать точку с запятой:
                                   
    $имя;[abc]

Здесь [abc] уже не часть выражения, потому что символ ; - это принудительное окончание выражения.
В этом случае сам символ ; не выводится в генерируемом документе. Если нам нужно, чтобы этот символ отобразился в том месте,
нужно написать его дважды:

    $имя;;[abc]

Здесь первый символ ; закрывает выражение, а второй отображается в документе как текст.                                   




### Операторы


Кроме переменных и функций в шаблоне можно использовать операторы.
Операторы позволяют управлять логикой постороения шаблона.
Все операторы выполняются на этапе генерации шаблона.




### Условный оператор


Условный оператор позволяет вывести ту или иную часть разметки документа на этапе генерации, в зависимости
от условия. Логика работы такая же как у условного оператора в Питоне.
В этом примере мы выводим приглашение для входа на сайт или имя пользователя, если он уже ввел логин и пароль:                                   

    def status():
        return html("""$if(http.user){<h4>User logged as $http.user<h4>}
                       $else{<h4>Please log in<h4>}""")

Здесь http.user это переменная, которая содержит информацию о пользователе сессии.
Более подробно об использовании переменной http.user можно почитать в разделе [Работа с сессиями](Sessions)

Синтаксис:
                                   
    $if(условие){ разметка1 }
    $elif(условие2){ разметка2 }
    $else{ разметка3 }



### Оператор цикла


Оператор цикла удобен при выводе повторяющихся строк, например при генерации таблицы.
Например в приложении есть список сообщений messages:

    messages = ["Message 1", "Message 2", "Message 3"]

Шаблон для вывода сообщений в виде HTML списка будет выглядеть так:
    <h1>Messages:</h1>
    <ul>
    $for(message in messages)
    {
        <li>$message</li>
    }
    </ul>

При генерации документа выводится весь текст, который заключен между фигурными скобками, включая переводы строк.
Синтаксис:                                   

    $for(список_переменных in последовательность) { разметка1 }
    $else{ разметка2 }

В логике работы оператора цикла есть некоторые отличия от аналогичного оператора языка Питон,
которые мы рассмотрим ниже. Эти отличия были сделаны для удобства использования шаблонов.
                    
Переменные из списка переменных будут доступны только в самом цикле, а при выходе из цикла будут удалены.
Если в программе существовали переменные с такими же именами, то они будут перекрыты на время
выполнения цикла, а при выходе из цикла им будут восстановлены предыдущие значения.
Это одно из отличий оператора цикла в Пони. В Питоне, если в цикле используется переменная с таким
же именем, после выхода из цикла ее значение не восстанавливается на значение до входа в цикл.

Этот же принцип применим и для вложенных операторов цикла в шаблонах. Если в качестве переменной
цикла используется одна и та же переменная, то при выходе из внутреннего цикла, переменной будет восстановлено
ее значение во внешнем цикле:
                    
    $for(a in sequence1) {
       <!-- здесь используется значение переменной $a из sequence1 -->
       $for(a in sequence2) {
          <!-- здесь используется значение переменной $a из sequence2 -->
       }
       <!-- здесь используется значение переменной $a из sequence1 -->
    }

Оператор цикла в шаблоне позволяет объявлять дополнительные переменные, которые могут быть доступны внутри цикла:
                    
    $for(a, b in sequence1; c = a + 1) {
      $a $b $c 
    }

В этом примере после символа ; внутри скобок задается переменная c.
Переменные вычисляются на каждом витке цикла.
Пони позволяет задавать любое количество дополнительных переменных:                                 

    $for(a, b in sequence1; c = a + 1; d = b * 2; e = c + d) {
      $a $b $c $d $e 
    }

Использование символа ; делает оператор цикла чем то похожим на аналогичный оператор в языках
Java и C++. Однако это только внешнее сходство.


### Использование "else" в операторе цикла


Другим отличием оператора цикла от аналогичного оператора в Питоне является логика работы части "else".
В Пони содержимое else выводится в том случае, если не был выполнен ни один из витков цикла.
В Питоне else выполняется если цикл не был прерван с помощью операции break.
Пример:
                    
    $for(msg in messages) {
        <!-- вывод списка сообщений -->
        Сообщение: $msg 
    )$else{
        <!-- список сообщений пуст -->
        Сообщений нет
    }




### Использование разделителя в операторе цикла


При использовании оператора цикла часто возникает необходимость разделять генерируемый в цикле текст.
Например с помощью запятой.
Если мы просто добавим вывод запятой в теле самого шаблона, запятая будет добавлена и в самом конце,
что может быть не то, что в данном случае нужно. Допустим в программе есть список сообщений
messages = ["one", "two", "three"]                    
Шаблон вида

    $for (msg in messages) {$msg, }

сгенерирует такой текст:

    one, two, three,

Чтобы вывести разделитель только между соседними фрагментами текста нужно использовать separator:

    $for (msg in messages) {$msg} $separator{, }

Сгенерированный текст в этом случае будет выглядеть так:

    one, two, three





### Функция cycle


Функция cycle служит для генерирования контента с определенной периодичностью.
Функция cycle может быть использована только внутри оператора for.
Пример:

    $for(var in sequence1) {
        $cycle(1, 2){ нечетная строка }
        $cycle(2, 2){ четная строка }
    }

Здесь первые два параметра функции - два числа. Второе задает период, а первое на каком
такте этого периода будет выводиться разметка, которая указана в фигурных скобках.
Для работы с четными и нечетными строками предусмотрена более удобная запись.
Этот фрагмент полностью повторяет функциональность предыдущего:                                   

    $for(var in sequence1) {
        $cycle("even"){ нечетная строка }
        $cycle("odd"){ четная строка }
    }

Здесь ключевое слово "even" определяет, что указанную разметку нужно выводить на нечетных витках цикла,
а "odd" - на четных. Вот список всех возможных ключевых слов в функции cycle:

        "odd"       - срабатывает на четных витках цикла
        "even"      - срабатывает на нечетных витках цикла
        "first"     - срабатывает только на первом витке цикла
        "not first" - срабатывает на всех витках цикла, кроме первого
        "last"      - срабатывает на последнем витке цикла
        "not last"  - срабатывает на всех витках цикла, кроме последнего

Существует еще один способ использования функции cycle. В этом случае после названия функции
указывается произвольное число разметок в фигурных скобках. При каждом обращении к функции,
она возвращает следующую по счету разметку, и так по кругу.
Пример:                                   

    $cycle{ разметка1 }{ разметка2 }{ разметка3 }

Если вызвать функцию 6 раз, то результатами вызова будут:

    разметка1
    разметка2
    разметка3
    разметка1
    разметка2
    разметка3
                                   



### Обработка исключений в шаблонах


Выражение try...except позволяет обрабатывать исключительные ситуации, которые могут возникнуть при генерации шаблона.
Допустим мы хотим вывести результат деления двух чисел: x/y. Если y будет равно нулю, или будет строкой вместо числа,
произойдет ошибка и выполнение шаблона прервется. Чтобы выполнение шаблона не прерывалось необходимо предусмотреть
обработку возможных исключений:

    $try { результат x/y = $(x/y) }
    $except { ошибка при делении x=$x на y=$y }

Синтаксис выражения try...except:                                   

    $try { разметка1 }
    $except(Exception1) { разметка2 }
    $except(Exception2) { разметка3 }
    $except { разметка4 }

Выражение может содержать несколько блоков except. Это выражение очень похоже на аналогичное выражения языка Питон.

Для выражения

    $try { разметка1 }
    $except { разметка2 }

существует более короткая запись:
                                   
    ${ разметка1 }{ разметка2 }

Это два блока разметки, которые идут один за другим. Если при обработке первого возникает ошибка, выполняется второй блок.                                 
Короткая запись для примера, рассмотренного ранее, выглядит следующим образом:

    ${ результат x/y = $(x/y) } { ошибка при делении x=$x на y=$y }
                                   



### Вызов функций


Пони позволяет вызывать из шаблона любые функции, которые доступны в модуле.
Рассмотрим пример.

    def div(x):
        return html('<div class="myclass">$x</div>')

Выражение print div("some text") вернет такой текст:

    <div class="myclass">some text</div>

Если мы вызываем функцию div из шаблона и в качестве параметра передаем разметку,
то эту разметку следует указывать в фигурных, а не в круглых скобках:

    $div{ <h1>Hello, $name!</h1> }

Результатом будет

    <div class="myclass"><h1>Hello, John!</h1></div>

В приведенном выше примере содержимое фигурных скобок является аргументом функции.
Это значит, что аргумент сначала вычисляется, а потом передается в функцию в виде готовой строки.
Иногда может быть удобно, чтобы разметка, которая передается в виде аргумента вычислялась только если это нужно,
в самой функции. Для этого предусмотрен декоратор @lazy:

    @lazy
    def div(x):
        x = x.eval()
        return html('<div class="myclass">$x</div>')    

При использовании декоратора @lazy нужно вычислять аргумент явно, с помощью метода eval().

Возможность передавать в качестве параметра разметку удобно использовать для генерации страниц с одинаковой раскладкой.
Например, каждая страница имеет три части: заголовок, меню и основную часть.
Функция mylayout содержит HTML шаблон, который располагет эти три части на странице.

    def mylayout(header, menu, body):
        return html("""
        ...
        ...
        """)

В приложении можно вызвать функцию mylayout с конкретными значениями для заголовка, меню и основной части из любого
места программы или другого шаблона и получить HTML код.

    $mylayout{ markup for header }{ markup for menu }{ markup for body }




### Использование объектов внутри шаблона


В примере, описанном выше мы передаем в функцию mylayout три аргумента.
Разработчику в этому случае нужно помнить порядок аргументов.
Чтобы улучшить читаемость кода, можно для этой цели использовать объекты.
Тогда шаблон для вышеописанного пример можно записать так:

    $MyLayout()
    $.header{ markup for header }
    $.menu{ markup for menu }
    $.body{ markup for body }

Здесь в первой строчке примера мы создаем экземпляр объекта MyLayout.
Затем производим вызов методов объекта. Символ $ в данном случае означает "последний созданный объект".
После последнего вызова метода объекта (в данном случае это $.body) Пони вызывает для объекта метод __str__
Эта возможность Пони позволяет разделить контент от способа его отображения.
Пример класса MyLayout:

    class MyLayout(object):
        def header(self, markup):
            self._header = markup
        def menu(self, markup):
            self._menu = markup
        def body(self, markup):
            self._body = markup
        def __str__(self):
            return html("""
                <div id="header">$(self._header)</div>
                <div id="menu">$(self._menu)</div>
                <div id="body">$(self._body)</div>                
                """)    




### Функция link

Назначение функции link - сгенерировать ссылку. В HTML документе может быть несколько типов ссылок:
ссылка на другую страницу, на файл с CSS стилями, на файл с javascript.

Для генерации ссылки на другую страницу веб-сайта функции link нужно передать два параметра:
текст ссылки, как он будет отображен на страницу и функцию, которая генерирует страницу:    

    link("текст ссылки", func)

Если для генерации страницы нужно передать какие-либо параметры(позиционные или именованные),
следует их записать через запятую после имени функции:

    link("текст ссылки", func, param1, param2, param3=x, param4=y)

Параметры, которые могут идти после названия функции мы будем обозначать таким образом:

    link("текст ссылки", func, ...)
    
Запятая и троеточие здесь означает, что в этом месте может идти любое количество параметров.
Если параметров у функции нет, то их просто не нужно указывать (тогда запятая после имени функции тоже не нужна).

Иногда возникает необходимость задать конкретный CSS стиль для отображения ссылки на странице.
В этом случае CSS класс указывается сразу после текста ссылки:

    link("текст ссылки", "CSS класс", func, ...)

Если нужно передать не только класс, а несколько аргументов для HTML тэга ссылки (тэга `<a>`),
вместо CSS класса следует передать словарь:

    link("текст ссылки", attrs, func, ...)

Здесь attrs - это словарь, в котором содержатся именя атрибутов и их значения.
Можно вызвать функцию link и без указания текста ссылки:

    link(func, ...)

В этом случае Пони возьмет текст ссылки из строки документации, заданной в функции. А если
в функции не задана строка документации, то в качестве текста ссылки будет использовано
имя самой функции.

Если для генерации шаблона нужен CSS файл, его можно легко включить в страницу:

    link("myfile.css")

Этот вызов сгенерирует тэг link, а не `<a>`, как для предыдущих примеров.
Чтобы Пони поняла, что это CSS файл, необходимо, чтобы у файла было расширение css.
Вот так в документа включается javascript:

    link("myfile.js")

Чтобы Пони поняла, что это javascript, у файла должно быть расширение js.
До текущего момента мы генерировали одиночные ссылки.
Пони тесно интегрирована с CSS фреймворком blueprint и javscript фреймворком jquery.
Чтобы включить все необходимые компоненты этих фрейморков достаточно вызвать функцию link
с указанием того, что нужно подключить:

    link("jquery")

    link("blueprint")

Если для генерации CSS раскладки нужно задать специфические параметры, можно их указать через запятую
после ключевого слова "blueprint":

    link("blueprint", column_width=40)

Детальное описание работы с фреймворком blueprint можно найти здесь: [Стандартные стили CSS](CssFramework)    




### Функция img


Функция img позволяет сгенерировать HTML тэг, который отображает картинку.
Первым параметром указывается текст, который будет отображен на странице в виде атрибута
title и атрибута alt. Второй параметр задает функцию, которая генерирует графический файл.

    img("text", func, ...)
    
Также как и для функции link, троеточие здесь означает произвольное количество параметров,
которые будут переданы функции func.
